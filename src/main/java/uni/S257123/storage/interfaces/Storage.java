package uni.S257123.storage.interfaces;
import org.apache.commons.lang3.tuple.Pair;
import uni.S257123.models.CSV;
import uni.S257123.storage.text.TextStorage;

import java.util.List;

/**
 * Defines the storage layer for an Inventory Management System.
 * <p>
 * This interface abstracts the methods necessary to interact with the stored data, regardless
 * of the specific mechanism of storage (e.g., text files, database).
 * It encapsulates all data manipulation methods such as adding, searching and more.
 * </p>
 * <p>At no point should any implementation for a method in this interface require user interaction
 * that should all be handled by the UI interfaces</p>
 */
public interface Storage {
    /**
     * Outputs a list of what datasource's data is being stored in.
     * @return string list of the available datasource's data is being stored in (without file extensions)
     */
    List<String> getSources();

    /**
     * Outputs the headers of a given file as a list of strings.
     * @param target the datasource you want to get headers from, without its file extension
     * @return all the headers the target file contains
     */
    List<String> getHeaders(String target);

    /**
     * Adds a new record to the specified location based on the provided parameters. It is the additional responsibility
     * of this method to ensure that a new ID is added if not autogenerated (e.g. {@link TextStorage#generateID()}) to
     * the provided parameters <i>if</i> being used to add to items.
     * It also should ensure that future operations are aware that this file has been added by adding a transaction.
     * @param parameters At a minimum, should provide:
     *                   <ol>
     *                   <li>Item Description</li>
     *                   <li>Unit Price</li>
     *                   <li>Quantity in Stock</li>
     *                   </ol>
     *                   It is up to the implementation whether providing the total price (calculated) is necessary
     * @param target the datasource for the record to be added to, without its file extension
     * @param transactionType either "added", "updated", or "deleted", based on what is being done to items
     * @return true if the record was successfully added
     */
    boolean addRecord(List<String> parameters, String target, String transactionType);

    boolean addRecord(List<String> parameters, String target);

    /**
     * Takes in an ID along with a property and value to update, and the items data-store to change the associated
     * values.
     * @param recordInfo index 0: record ID, index 1: property wanted to be edited, index 2: what the value to be edited
     *                  to is
     */
    void updateRecord(List<String> recordInfo);

    /**
     * Takes in an id, and deletes the record that matches that row.
     * @param id the id of the row to be removed
     */
    void deleteRecord(String id);

    /**
     * Reads the contents of the provided datasource, and returns a list of {@link CSV} objects, with each object representing
     * one row of the data.
 	 * <p>
 	 * Note: This method reads the entire file every time it's called. Potential performance
 	 * improvements could be achieved by reading only changed or unread rows.
 	 * </p>
     * @param target the datasource to be read from, missing any file extensions if applicable
     * @return a list of CSV objects, each representing one row of the file
     */
    List<CSV> readContents(String target);

    /**
     * Searches a selected datasource to see if a certain value matches any pre-existing data for the specified property.
     * <p>
     * Searches through the datasource at target, checking if the property specified by
     * propertyNameValuePair matches (or contains) the provided value within the same Pair. Matching is done using a
     * regular expression of ".*SEARCH.*". All matching CSV rows are returned
     * </p>
     * @param target the name of datasource that you want to search (minus any extensions if applicable)
     * @param propertyNameValuePair the property you want to search (left), and the value to search for (right)
     * @return a list of {@link CSV} objects that match the chosen search
     * @see #searchRecord()
     */
    List<CSV> searchRecord(String target, Pair<String, String> propertyNameValuePair);
    /**
     * Searches for a record using default search parameters.
     * This is a convenience method that uses "items" as the table name
     * and an empty string for the ID search criteria by default.
     * For custom search parameters, use {@link #searchRecord(String, Pair)}.
     */
    default List<CSV> searchRecord() {
        return searchRecord("items", Pair.of("id", ""));
    }

    /**
     * Fetches the list of ID's from the storage location.
     * @return A list of strings where each string is one ID
     */
    List<String> getIDs();
}
